#! /usr/bin/python
# -*- coding: utf-8 -*-
# The sequence of triangle numbers is generated by adding the natural numbers. 
# So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
# The first ten terms would be:
#
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#
# Let us list the factors of the first seven triangle numbers:
#
#     1: 1
#     3: 1,3
#     6: 1,2,3,6
#    10: 1,2,5,10
#    15: 1,3,5,15
#    21: 1,3,7,21
#    28: 1,2,4,7,14,28
#
# We can see that 28 is the first triangle number to have over five divisors.
#
# What is the value of the first triangle number to have over five hundred divisors?

### Solution
## Triangle number could be found by the formular
##
## T(n) = Sigma of k (for k =1 to n) = 1+2+3+...+n = (n(n+1))/2

import time
import math

def is_prime(n):
  if (n<13):
    for i in range(2, n):
      if n%i == 0:
        return False
    return True
  else:
    maxval = int(math.sqrt(n))
    for i in range(2, maxval + 1):
      if n%i == 0:
        return False
        break
    return True


divisible = [] 
value = 0
number_of_divisors = 0
tempvalue = 0
starttime = time.clock()

for counter in range (1, 10000000):
  T_n = (counter * (counter +1))/2
  if (is_prime(T_n)):
    pass
  else:
    for i in range (1, T_n + 1):
      value = T_n % i
      if (value == 0):
        if not (i in divisible):
          divisible.append(i)
    divisible.sort()
    number_of_divisors = len (divisible)
    ## print (number_of_divisors, "   ", divisible)
    if (number_of_divisors <= 500):
      del divisible[:]
      if (tempvalue < number_of_divisors):
        tempvalue = number_of_divisors
        print (number_of_divisors, "      ", T_n)
    else:
      print (number_of_divisors, "   ", divisible)
      break
stoptime = time.clock()
print "%.2gs" % (stoptime - starttime)

## Post operation analysis
## This program took 13.3 hours to run - This brute force method worked but not the fastest one.  I am going to design a new way to solve this problem
## 6/27/2016

