#! /usr/bin/python
# -*- coding: utf-8 -*-
# The sequence of triangle numbers is generated by adding the natural numbers. 
# So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
# The first ten terms would be:
#
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#
# Let us list the factors of the first seven triangle numbers:
#
#     1: 1
#     3: 1,3
#     6: 1,2,3,6
#    10: 1,2,5,10
#    15: 1,3,5,15
#    21: 1,3,7,21
#    28: 1,2,4,7,14,28
#
# We can see that 28 is the first triangle number to have over five divisors.
#
# What is the value of the first triangle number to have over five hundred divisors?

### Solution
## Triangle number could be found by the formular
##
## T(n) = Sigma of k (for k =1 to n) = 1+2+3+...+n = (n(n+1))/2

import time
import math

def is_prime(n):
  if (n<13):
    for i in range(2, n):
      if n%i == 0:
        return False
    return True
  else:
    maxval = int(math.sqrt(n))
    for i in range(2, maxval + 1):
      if n%i == 0:
        return False
        break
    return True


def check_for_divisors(s1, s2, num):
  outloop = len(s1)
  for n in range (0, outloop):
    for value in s1:
      newvalue = s1[n] * value
      if ((newvalue not in s2) and (newvalue <= num) and (num % newvalue == 0)):
        s2.append(newvalue)
  for value in s2:
    if value not in divisors:
      divisors.append(value)



def check_for_term(num):
  global divisors
  base = []
  set1 = []
  set2 = []
  done = False
  if ((is_prime(num)) and (num > 17)):
    print ("Prime number, so skipped")
    pass
  else:
    base.append(1) ## all number divisible by 1
    base.append(num)  ## all number divisible by itself
    if ((num % 2 == 0)):
      base.append(2)
      divisors.append(2)
    if ((num % 3 == 0)):
      base.append(3)
      divisors.append(3)
    if ((num % 5 == 0)):
      divisors.append(5)
      base.append(5)
    if ((num % 7 == 0)):
      divisors.append(7)
      base.append(7)
    if ((num % 11 == 0)):
      divisors.append(11)
      base.append(11)
    if ((num % 13 == 0)):
      divisors.append(13)
      base.append(13)
    if ((num % 17 == 0)):
      divisors.append(17)
      base.append(17)
    if ((num % 23 == 0)):
      divisors.append(23)
      base.append(23)
    ## Check for divisible term and shit
    check_for_divisors(base,base,num)
    check_for_divisors(base,set1,num)

divisors = [] 
value = 0
number_of_divisors = 0
tempvalue = 0
starttime = time.clock()



for counter in range (1,10000000):
  T_n = (counter * (counter +1))/2
  print ("Counter = " + str(counter) + " Term = " + str(T_n))
  ## now the term included 1 and itself
  divisors[:] = [] ## empty this out first
  check_for_term(T_n)
  divisors.sort()
  if (len(divisors)>500):
    print ("Divisors for " + str(T_n))
    print divisors
    break

stoptime = time.clock()
print "%.2gs" % (stoptime - starttime)


## Post operation:  It took only 19s - I did not believe it myself
## the number is 76,576,500 that has more than 500 terms
